<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Leaflet + Draw + Context Menu + Tracked + WebRTC (Refactored)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet.Draw -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- QWebChannel for Python communication (optional in Qt) -->
  <script src="qrc:///qtwebchannel/qwebchannel.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    .leaflet-draw-toolbar { display: none; }

    /* 컨텍스트 / 마커 / 폴리곤 메뉴 */
    #ctxMenu, #markerMenu, #polyMenu{
      position:absolute; z-index:10000; display:none;
      background:#fff; border:1px solid #ccc; border-radius:8px;
      box-shadow:0 6px 18px rgba(0,0,0,.15); min-width:160px;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;
    }
    #ctxMenu button, #markerMenu button, #polyMenu button{
      width:100%; padding:10px 12px; border:none; background:#fff;
      text-align:left; cursor:pointer; font-size:14px;
    }
    #ctxMenu button:hover, #markerMenu button:hover, #polyMenu button:hover{ background:#f2f2f2; }

    /* 비디오 팝업 스타일 */
    .video-popup .leaflet-popup-content-wrapper {
      border-radius:10px; box-shadow:0 10px 24px rgba(0,0,0,.25);
    }
    .video-popup .leaflet-popup-content { margin:8px 10px; width:360px; }
    .video-popup video { width:100%; background:#000; border-radius:8px; }

    /* 상단 메시지 */
    #topMessage {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%) translateY(-8px);
      background: rgba(0,0,0,0.78);
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 6px 18px rgba(0,0,0,.2);
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease, transform 200ms ease;
      font-size: 14px;
      line-height: 1.4;
    }
    #topMessage.show {
      opacity: 1;
      pointer-events: auto;
      transform: translateX(-50%) translateY(0);
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="topMessage" aria-live="polite"></div>

  <!-- 메뉴들 -->
  <div id="ctxMenu">
    <button id="addMarkerBtn">마커 추가</button>
    <button id="deleteAllMarkerBtn">모든 마커 삭제</button>
    <!-- <button id="addPolygonBtn">폴리곤 추가</button> -->
  </div>
  <div id="markerMenu">
    <button id="mkDeleteBtn">마커 삭제</button>
    <button id="editMarkerBtn">마커 편집</button>
  </div>
  <!-- <div id="polyMenu"><button id="polyDeleteBtn">이 폴리곤 삭제</button></div> -->

  <script>
  /**************************************************************************
   * 설정
   ***************************************************************************/
  const MTX_ORIGIN = "http://192.168.88.44:8889"; // MediaMTX WebRTC
  const CAMS = [{ id:"cam1", title:"cam1", lat:35.5396, lng:129.3115 }];

  const COLORS = {
    SENSOR_STROKE_DEFAULT: '#666',
    SENSOR_FILL_DEFAULT: '#808080',
    RED: '#ff3b30',
    GREEN: '#34c759',
    RANGE: '#3388ff',
    BLUE: '#007AFF',
    INFO_BG: 'rgba(0,0,0,0.78)',
    DOT: '#111'
  };

  // 센서 좌표
  const FireSensorCircleCoords = [
    [35.565826,129.089228],
    [35.557858,129.031257],
    [35.585640,129.043495],
    [35.583097,129.029397],
    [35.609971,129.020138],
    [35.552318,129.056796],
    [35.578857,129.063614],
    [35.627928,129.040288]
  ];

  /**************************************************************************
   * 전역 상태
   ***************************************************************************/
  const map = L.map('map',{center:[35.5770913,129.0988505],zoom:13});
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

  const FireSensorMarkers = [];         // L.Marker
  const FireSensorRangeCircles = [];    // L.Circle
   let FireSensorStatuses = [];          // 최근 상태 배열 (index 기준 주의)
   let lastDroneData = null;
   // 사용자 입력 저장 변수
   let point_degree = null;
   let point_zoom = null;

  /**************************************************************************
   * 유틸리티
   ***************************************************************************/
  function iconPxForZoom(z) {
    const base = 32; // zoom 13 기준 32px
    const factor = Math.pow(1.12, z - 13);
    return Math.round(base * factor);
  }

  function safeParseFloat(v, defaultVal = 0) {
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : defaultVal;
  }

  /**************************************************************************
   * 센서 마커 생성 및 상태 업데이트
   ***************************************************************************/
  function setSensorMarkerIcon(marker, iconUrl) {
    if (!marker) return;
    const size = iconPxForZoom(map.getZoom());
    marker.setIcon(L.icon({
      iconUrl: iconUrl,
      iconSize: [size, size],
      iconAnchor: [size / 2, size / 2]
    }));
  }

  function initFireSensors() {
    FireSensorCircleCoords.forEach(([lat, lng], idx) => {
      const m = L.marker([lat, lng]).addTo(map);
      setSensorMarkerIcon(m, 'fire.png');
      FireSensorMarkers[idx] = m;

      m.on('click', () => {
        if (window.pyHandler && window.pyHandler.onFireSensorClick) {
          // Python handler(optional)
          try { window.pyHandler.onFireSensorClick(idx, lat, lng); } catch(e){ console.warn(e); }
        }
      });

      const range = L.circle([lat, lng], {
        radius: 1000,
        color: COLORS.RANGE,
        weight: 2,
        fillColor: COLORS.RANGE,
        fillOpacity: 0.1,
        interactive: false
      }).addTo(map);
      FireSensorRangeCircles[idx] = range;
    });
  }

  /**
   * 산불 감지 센서 표기
   */
  function setFireSensorColors(statusList) {
    if (!Array.isArray(statusList)) return;
    FireSensorStatuses = statusList;

    statusList.forEach(item => {
      if (!item || typeof item.index !== 'number') return;
      const idx = item.index - 1;
      const m = FireSensorMarkers[idx];
      const range = FireSensorRangeCircles[idx];
      if (!m) return;

      const flags = Number(item.flags) || 0;
      const gas = Number(item.gas_index) || 0;

      let iconUrl = 'fire.png';
      if (flags === 0) iconUrl = 'fire.png';
      else if (flags === 1 && gas === 100) iconUrl = 'fire_on.png';
      else iconUrl = 'fire_off.png';

      setSensorMarkerIcon(m, iconUrl);

      if (range) {
        if (flags === 0) {
          range.setStyle({ color: COLORS.SENSOR_STROKE_DEFAULT, fillColor: COLORS.SENSOR_FILL_DEFAULT, fillOpacity: 0.20 });
        } else if (flags === 1 && gas === 100) {
          range.setStyle({ color: COLORS.RED, fillColor: COLORS.RED, fillOpacity: 0.25 });
        } else {
          range.setStyle({ color: COLORS.BLUE, fillColor: COLORS.BLUE, fillOpacity: 0.25 });
        }
      }
    });
  }

  // 줌 변경 시 아이콘 크기 다시 조정
  map.on('zoomend', () => {
    FireSensorMarkers.forEach((m, idx) => {
      const st = FireSensorStatuses[idx];
      let iconUrl = 'fire.png';
      if (st) {
        if (st.flags === 0) iconUrl = 'fire.png';
        else if (st.flags === 1 && st.gas_index === 100) iconUrl = 'fire_on.png';
        else iconUrl = 'fire_off.png';
      }
      setSensorMarkerIcon(m, iconUrl);
    });
  });

  /**************************************************************************
   * 추적 레이어 (tracked) - 임무장비 표시
   ***************************************************************************/
  const trackedLayerGroup = L.layerGroup().addTo(map);
  const canvasRenderer = L.canvas({ padding: 0.5 });

  let tracked = { marker: null, latlng: null, heading: 0, headingLine: null, cameraHeadingLine: null, rangeCircle: null };

  function clearTracked() {
    if (tracked.marker) trackedLayerGroup.removeLayer(tracked.marker);
    if (tracked.headingLine) trackedLayerGroup.removeLayer(tracked.headingLine);
    if (tracked.cameraHeadingLine) trackedLayerGroup.removeLayer(tracked.cameraHeadingLine);
    if (tracked.rangeCircle) trackedLayerGroup.removeLayer(tracked.rangeCircle);
    tracked = { marker: null, latlng: null, heading: 0, headingLine: null, cameraHeadingLine: null, rangeCircle: null };
  }

  function destinationPoint(lat, lng, bearing, distance) {
    const R = 6371000;
    const brng = bearing * Math.PI / 180;
    const φ1 = lat * Math.PI / 180;
    const λ1 = lng * Math.PI / 180;
    const δ = distance / R;
    const φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(brng));
    const λ2 = λ1 + Math.atan2(Math.sin(brng) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));
    return { lat: φ2 * 180 / Math.PI, lng: ((λ2 * 180 / Math.PI + 540) % 360) - 180 };
  }

  function makeHeadingIcon(deg = 0) {
    const safe = (deg % 360 + 360) % 360;
    return L.divIcon({
      className: "",
      iconSize: [28, 28],
      iconAnchor: [14, 14],
      html: `<div style="position:relative;width:30px;height:30px;">
        <div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(1)">
          <div style="width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:20px solid ${COLORS.RED};transform:rotate(${safe}deg);"></div>
          <div style="position:absolute;left:50%;top:50%;width:8px;height:8px;border-radius:50%;background:${COLORS.DOT};transform:translate(-50%,-50%);"></div>
        </div>
      </div>`
    });
  }

  /**
   * upsertTracked({ lat, lng, heading, camera_yaw, onClick })
   */
  function upsertTracked({ lat, lng, heading = 0, camera_yaw = null, onClick = null }) {
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      console.warn("Invalid tracked lat/lng", lat, lng);
      return;
    }
    const ll = L.latLng(lat, lng);
    const hdg = (heading % 360 + 360) % 360;

    if (!tracked.marker) {
      tracked.marker = L.marker(ll, { icon: makeHeadingIcon(hdg) }).addTo(trackedLayerGroup);
      if (typeof onClick === 'function') tracked.marker.on('click', onClick);
    } else {
      tracked.marker.setLatLng(ll);
      if (typeof onClick === 'function') {
        tracked.marker.off('click');
        tracked.marker.on('click', onClick);
      }
    }
    tracked.marker.setIcon(makeHeadingIcon(hdg));
    tracked.latlng = ll;
    tracked.heading = hdg;

    // heading line
    const end = destinationPoint(lat, lng, hdg, 1000);
    if (!tracked.headingLine) {
      tracked.headingLine = L.polyline([ll, [end.lat, end.lng]], { color: COLORS.RED, weight: 3, renderer: canvasRenderer }).addTo(trackedLayerGroup);
    } else {
      tracked.headingLine.setLatLngs([ll, [end.lat, end.lng]]);
    }

    // camera heading line (optional)
    if (camera_yaw !== null && camera_yaw !== undefined) {
      const camRel = hdg + camera_yaw; // headingLine을 기준으로 camera 라인 설정
      const camHdg = (camRel % 360 + 360) % 360;
      const camEnd = destinationPoint(lat, lng, camHdg, 800);
      if (!tracked.cameraHeadingLine) {
        tracked.cameraHeadingLine = L.polyline([ll, [camEnd.lat, camEnd.lng]], {
          color: COLORS.BLUE, weight: 2, dashArray: "5,4", renderer: canvasRenderer
        }).addTo(trackedLayerGroup);
      } else {
        tracked.cameraHeadingLine.setLatLngs([ll, [camEnd.lat, camEnd.lng]]);
      }
    } else if (tracked.cameraHeadingLine) {
      trackedLayerGroup.removeLayer(tracked.cameraHeadingLine);
      tracked.cameraHeadingLine = null;
    }

    if (!tracked.rangeCircle) {
      tracked.rangeCircle = L.circle(ll, { radius: 1000, color: COLORS.RANGE, weight: 2, fillOpacity: 0.1, renderer: canvasRenderer }).addTo(trackedLayerGroup);
    } else {
      tracked.rangeCircle.setLatLng(ll);
    }
  }

  function focusTracked() {
    if (tracked && tracked.latlng) {
      map.setView(tracked.latlng, 15);
    }
  }

  /**************************************************************************
   * WebRTC (WHEP) - 간단한 구현
   ***************************************************************************/
  async function startWebRTC(videoEl, camId) {
    if (!videoEl) return;
    let pc = null;
    try {
      pc = new RTCPeerConnection();
      pc.ontrack = (e) => { videoEl.srcObject = e.streams[0]; };
      pc.oniceconnectionstatechange = () => {
        if (pc && pc.iceConnectionState === 'failed') console.warn('ICE failed for', camId);
      };

      const offer = await pc.createOffer({ offerToReceiveVideo: true });
      await pc.setLocalDescription(offer);
      console.log("Local SDP created");

      const resp = await fetch(`${MTX_ORIGIN}/${camId}/whep`, {
        method: "POST",
        body: pc.localDescription.sdp,
        headers: { "Content-Type": "application/sdp" }
      });

      if (!resp.ok) throw new Error(`WHEP request failed ${resp.status}`);
      const answerSDP = await resp.text();
      await pc.setRemoteDescription({ type: "answer", sdp: answerSDP });
      console.log("Remote SDP applied");
    } catch (err) {
      console.error("startWebRTC error:", err);
      if (pc) try { pc.close(); } catch(e) {}
    }
  }

  let videoPopup = null;
  function openVideoAt(latlng, title, camId) {
    if (videoPopup) map.closePopup(videoPopup);
    const content = document.createElement('div');
    content.innerHTML = `<div style="margin-bottom:6px;"><b>${title}</b></div><video autoplay playsinline muted controls></video>`;
    videoPopup = L.popup({ className: 'video-popup', closeButton: true, offset: [14, -10] }).setLatLng(latlng).setContent(content).openOn(map);
    const video = content.querySelector('video');
    startWebRTC(video, camId);
  }

  /**************************************************************************
   * 드로잉 & 컨텍스트 메뉴
   ***************************************************************************/
  const drawnItems = new L.FeatureGroup().addTo(map);
  const drawOptions = {
    draw: { polygon: false, marker: true, polyline: false, rectangle: false, circle: false, circlemarker: false },
    edit: { featureGroup: drawnItems }
  };
  const drawControl = new L.Control.Draw(drawOptions); map.addControl(drawControl);

  const markers = {}; // polygons disabled
  let lastCtxLatLng = null, currentMarkerId = null; // currentPolygonId and currentPolygonLayer disabled

  // POI 마커 저장소
  const poiMarkers = {}; // id(string) -> L.Marker
  const poiData = {};    // id(string) -> { poi_id, lat, lng, altitude, zoom_level }

  // Python에서 전달받은 POI 리스트를 지도에 표시
  function renderPoiMarkers(list) {
    try {
      if (!Array.isArray(list)) return;
      list.forEach(p => {
        const id = String(p.poi_id);
        if (id === 'null' || id === 'undefined') return;
        if (poiMarkers[id]) return; // 중복 추가 방지
        const lat = parseFloat(p.lat);
        const lng = parseFloat(p.lng);
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
        const m = L.marker([lat, lng]).addTo(map);
        m.on('click', ev => {
          hideMenus();
          if (!markerActionsEnabled) return;
          markerMenu.style.left = ev.containerPoint.x + "px";
          markerMenu.style.top = ev.containerPoint.y + "px";
          markerMenu.style.display = "block";
          currentMarkerId = `poi_${id}`;
        });
        // 마우스 오버 시 마커 바로 위에 정보 표시
        try {
          const infoHtml = `<div><b>POI ${id}</b>` +
                           `<br>Lat: ${lat.toFixed(6)}` +
                           `<br>Lng: ${lng.toFixed(6)}` +
                           (`altitude` in p && p.altitude !== undefined && p.altitude !== null ? `<br>Alt: ${p.altitude}` : '') +
                           (`zoom_level` in p && p.zoom_level !== undefined && p.zoom_level !== null ? `<br>Zoom: ${p.zoom_level}` : '') +
                           `</div>`;
          m.bindTooltip(infoHtml, {
            direction: 'top',
            offset: [0, -12],
            opacity: 0.95,
            className: 'poi-tooltip'
          });
        } catch (e) { console.warn('bindTooltip error:', e); }
        poiMarkers[id] = m;
        poiData[id] = { poi_id: p.poi_id, lat: lat, lng: lng, altitude: p.altitude, zoom_level: p.zoom_level };
      });
      console.log('POI 마커 렌더링 완료:', Object.keys(poiMarkers).length);
    } catch (e) {
      console.warn('renderPoiMarkers error:', e);
    }
  }

  // 가장 가까운 POI id 찾기 (임계값 이내)
  function nearestPoiId(latlng, maxDistMeters = 80) {
    let bestId = null, bestDist = Infinity;
    Object.keys(poiMarkers).forEach(id => {
      const dist = map.distance(latlng, poiMarkers[id].getLatLng());
      if (dist < bestDist) { bestDist = dist; bestId = id; }
    });
    return (bestDist <= maxDistMeters) ? bestId : null;
  }

  const ctxMenu = document.getElementById('ctxMenu'),
        markerMenu = document.getElementById('markerMenu'); // const polyMenu = document.getElementById('polyMenu');

  function hideMenus(){ ctxMenu.style.display="none"; markerMenu.style.display="none"; /* polyMenu.style.display="none"; */ }

  // 지정 좌표에 마커 추가 (Python에서도 호출할 수 있도록 전역 함수)
  function addMarkerAt(lat, lng) {
    const id = `m_${Date.now()}`;
    const m = L.marker([lat, lng]).addTo(map);
    m.on('click', ev => {
      hideMenus();
      if (!markerActionsEnabled) return;
      markerMenu.style.left = ev.containerPoint.x + "px";
      markerMenu.style.top = ev.containerPoint.y + "px";
      markerMenu.style.display = "block";
      currentMarkerId = id;
    });
    markers[id] = m;
  }

  map.on('contextmenu', e => {
    hideMenus();
    lastCtxLatLng = e.latlng;
    ctxMenu.style.left = e.containerPoint.x + "px";
    ctxMenu.style.top = e.containerPoint.y + "px";
    ctxMenu.style.display = "block";
  });
  ['click','movestart','zoomstart'].forEach(ev => map.on(ev, hideMenus));

    /**************************************************************************
   * 마커 추가 알림창 설정 및 좌표/줌/각도 입력 값 main.py 전달
   ***************************************************************************/
  document.getElementById('addMarkerBtn').onclick = () => {
    hideMenus();
    if (!markerActionsEnabled) return;

    // 우클릭 위치(컨텍스트 메뉴 기준)가 없으면 중단
    if (!lastCtxLatLng) {
      console.warn('컨텍스트 위치가 없습니다. 지도에서 우클릭 후 마커를 추가하세요.');
      return;
    }

    // Qt 환경: Python에 다이얼로그 요청 (QInputDialog/메시지 박스 스타일)
    if (window.pyHandler && typeof window.pyHandler.requestMarkerInputs === 'function') {
      try { window.pyHandler.requestMarkerInputs(lastCtxLatLng.lat, lastCtxLatLng.lng); } catch (err) { console.warn('requestMarkerInputs error:', err); }
      return; // 입력 및 마커 생성은 Python/Qt에서 처리
    }
  };

  // const addPolygonBtn = document.getElementById('addPolygonBtn');
  // if (addPolygonBtn) addPolygonBtn.onclick = () => { hideMenus(); new L.Draw.Polygon(map).enable(); };

  document.getElementById('mkDeleteBtn').onclick = () => {
    if (!markerActionsEnabled) { hideMenus(); return; }
    // 현재 선택된 마커가 없으면 종료
    if (!currentMarkerId) { hideMenus(); return; }

    const id = currentMarkerId;

    // POI 마커인 경우: poiMarkers/poiData에서 제거 + Python 콜백
    if (id.startsWith('poi_')) {
      const pid = id.slice(4);
      if (poiMarkers[pid]) {
        try { map.removeLayer(poiMarkers[pid]); } catch(e){}
        delete poiMarkers[pid];
        if (poiData) delete poiData[pid];
      }
      if (window.pyHandler && typeof window.pyHandler.deleteMarker === 'function') {
        try { window.pyHandler.deleteMarker(parseInt(pid, 10)); } catch (err) { console.warn('deleteMarker error:', err); }
      }
      currentMarkerId = null;
      hideMenus();
      return;
    }

    // 사용자 추가 마커인 경우: 지도에서만 제거
    if (markers[id]) {
      try { map.removeLayer(markers[id]); } catch(e){}
      delete markers[id];
      currentMarkerId = null;
    }
    hideMenus();
  };

  // 모든 마커 삭제
  const deleteAllBtn = document.getElementById('deleteAllMarkerBtn');
  if (deleteAllBtn) deleteAllBtn.onclick = () => {
    hideMenus();
    try {
      // 사용자 추가 마커 제거
      Object.keys(markers).forEach(id => {
        try { map.removeLayer(markers[id]); } catch(e){}
        delete markers[id];
      });
      // POI 마커 제거 (DB에서 불러온 표시용)
      Object.keys(poiMarkers || {}).forEach(id => {
        try { map.removeLayer(poiMarkers[id]); } catch(e){}
        delete poiMarkers[id];
        if (poiData) delete poiData[id];
      });
      currentMarkerId = null;
      if (window.pyHandler && typeof window.pyHandler.deleteAllMarkers === 'function') {
        try { window.pyHandler.deleteAllMarkers(); } catch(e) { console.warn('deleteAllMarkers error:', e); }
      }
      console.log('모든 마커 삭제 완료');
    } catch (err) {
      console.warn('모든 마커 삭제 중 오류:', err);
    }
  };

  // 컨텍스트 메뉴: 마커 편집 (POI 대상)
  document.getElementById('editMarkerBtn').onclick = () => {
    hideMenus();
    if (!markerActionsEnabled) return;
    try {
      console.log('[디버그] 편집 시작', {
        markerActionsEnabled,
        currentMarkerId,
        lastCtxLatLng,
        poiKeys: Object.keys(poiData || {}),
        poiMarkerKeys: Object.keys(poiMarkers || {})
      });
    } catch (e) {}

    // 우선 현재 선택된 마커가 POI인지 확인
    let targetId = null;
    if (currentMarkerId && currentMarkerId.startsWith('poi_')) {
      targetId = currentMarkerId.slice(4);
      try { console.log('[디버그] 선택 마커 기반 편집 대상', { targetId }); } catch (e) {}
    } else if (lastCtxLatLng) {
      targetId = nearestPoiId(lastCtxLatLng, 80);
      try { console.log('[디버그] 근접 탐색 기반 편집 대상', { targetId, 기준좌표: lastCtxLatLng }); } catch (e) {}
    }

    if (!targetId || !poiData[targetId]) {
      try {
        console.warn('편집할 POI 마커를 찾을 수 없습니다. 마커를 클릭 후 시도하세요.', {
          targetId,
          poi존재여부: !!(targetId && poiData[targetId])
        });
      } catch (e) {}
      return;
    }

    const p = poiData[targetId];
    try { console.log('[디버그] 편집 대상 POI 데이터', p); } catch (e) {}
    // Qt 환경: Python에 편집 입력 요청 (기본값 altitude/zoom_level)
    if (window.pyHandler && typeof window.pyHandler.requestEditMarkerInputs === 'function') {
      try {
        console.log('[디버그] Python 요청: requestEditMarkerInputs', { targetId });
        window.pyHandler.requestEditMarkerInputs(parseInt(targetId, 10));
      } catch (err) { console.warn('requestEditMarkerInputs error:', err); }
      return;
    }

    // 브라우저 프리뷰 환경: 기본값으로 프롬프트 제공
    const degDefault = (p.altitude !== undefined && p.altitude !== null) ? String(p.altitude) : '';
    const zoomDefault = (p.zoom_level !== undefined && p.zoom_level !== null) ? String(p.zoom_level) : '';
    try { console.log('[디버그] 프롬프트 기본값', { degDefault, zoomDefault }); } catch (e) {}
    const deg = window.prompt('대상 각도 입력 (-180 ~ 180)', degDefault);
    if (deg === null) return;
    const zd = window.prompt('줌 레벨 입력 (0~10 정수)', zoomDefault);
    if (zd === null) return;
    const degreeVal = parseFloat(deg);
    const zoomVal = parseInt(zd, 10);
    if (!Number.isFinite(degreeVal) || degreeVal < -180 || degreeVal > 180) { console.warn('각도 입력 무효'); return; }
    if (!Number.isInteger(zoomVal) || zoomVal < 0 || zoomVal > 10) { console.warn('줌 입력 무효'); return; }
    console.log(`POI 편집(프리뷰): poi_id=${targetId}, degree=${degreeVal}, zoom=${zoomVal}, lat=${p.lat}, lng=${p.lng}`);
  };

  /*
  document.getElementById('polyDeleteBtn').onclick = () => {
    if (currentPolygonId && currentPolygonLayer) {
      drawnItems.removeLayer(currentPolygonLayer);
      delete polygons[currentPolygonId];
      currentPolygonId = null; currentPolygonLayer = null;
    }
    hideMenus();
  };
  */

  map.on(L.Draw.Event.CREATED, e => {
    const layer = e.layer;
    drawnItems.addLayer(layer);
    /* if (e.layerType === 'polygon') {
       const id = `p_${Date.now()}`;
       polygons[id] = layer;
       layer.on('click', ev => {
         hideMenus();
         polyMenu.style.left = e.containerPoint.x + "px";
         polyMenu.style.top = e.containerPoint.y + "px";
         polyMenu.style.display = "block";
         currentPolygonId = id;
         currentPolygonLayer = layer;
       });
     } */
  });

  // 마우스 위치를 Python (Qt) 에 전달
  map.on('mousemove', function(e) {
    if (window.pyHandler && typeof window.pyHandler.updateCursorLatLng === 'function') {
      try { window.pyHandler.updateCursorLatLng(e.latlng.lat, e.latlng.lng); } catch (err) { console.warn(err); }
    }
  });

  /**************************************************************************
   * 상단 메시지 표시
   ***************************************************************************/
  let __topMsgCenterIndex = null;
  function showTopMessage(text, opts = {}) {
    const el = document.getElementById('topMessage');
    const type = opts.type || 'info';
    const size = opts.size || 'medium';
    el.textContent = text || '';

    const centerIdx = (typeof opts.centerSensorIndex === 'number') ? opts.centerSensorIndex : null;
    __topMsgCenterIndex = centerIdx;

    let bg = COLORS.INFO_BG;
    if (type === 'warn') bg = COLORS.RED;
    else if (type === 'success') bg = COLORS.GREEN;
    el.style.background = bg;

    if (size === 'large') { el.style.fontSize = '18px'; el.style.padding = '14px 18px'; }
    else if (size === 'small') { el.style.fontSize = '13px'; el.style.padding = '6px 10px'; }
    else { el.style.fontSize = '16px'; el.style.padding = '12px 16px'; }

    el.classList.add('show');
  }

  document.getElementById('topMessage').addEventListener('click', () => {
    const el = document.getElementById('topMessage');
    if (__topMsgCenterIndex !== null) {
      const coords = FireSensorCircleCoords[__topMsgCenterIndex];
      if (coords) map.setView(coords, 15);
    }
    el.classList.remove('show');
    __topMsgCenterIndex = null;
  });

  /**************************************************************************
   * 드론/임무장비 데이터 업데이트 (외부에서 호출)
   ***************************************************************************/
  function updateDroneData(data, deviceName = "Drone") {
    console.log("임무장비 데이터 업데이트:", data);
    if (!data) return;

    const lat = safeParseFloat(data.latitude, NaN);
    const lng = safeParseFloat(data.longitude, NaN);
    if (Number.isNaN(lat) || Number.isNaN(lng)) {
      console.warn("GPS 좌표 무효: 추적 중지 또는 무시");
      clearTracked();
      lastDroneData = data;
      return;
    }

    const yaw = safeParseFloat(data.yaw, 0);
    const camera_yaw = (data.camera_yaw !== undefined && data.camera_yaw !== null) ? safeParseFloat(data.camera_yaw, null) : null;

    upsertTracked({
      lat: lat,
      lng: lng,
      heading: yaw,
      camera_yaw: camera_yaw,
      onClick: () => {
        // Python 콜백 요청 (있다면)
        if (window.pyHandler && typeof window.pyHandler.showCameraDialog === 'function') {
          try { window.pyHandler.showCameraDialog(data); } catch(e){ console.warn(e); }
        }
        const title = deviceName || (data.missiondevice_serial_number || "Tracked Device");
        openVideoAt(L.latLng(lat, lng), title, 'drone_cam');
      }
    });

    // 첫 수신이면 중심 이동
    if (!lastDroneData) {
      map.setView([lat, lng], 15);
    }
    lastDroneData = data;
  }

  /**************************************************************************
   * 마커 작업 버튼 표시/숨김 토글 함수
   ***************************************************************************/
  var markerActionsEnabled = false;
  function setMarkerActionEnabled(enabled) {
    try {
      markerActionsEnabled = !!enabled;
      const addBtn = document.getElementById('addMarkerBtn');
      const delBtn = document.getElementById('mkDeleteBtn');
      const editBtn = document.getElementById('editMarkerBtn');
      if (addBtn) addBtn.style.display = markerActionsEnabled ? 'block' : 'none';
      if (delBtn) delBtn.style.display = markerActionsEnabled ? 'block' : 'none';
      if (editBtn) editBtn.style.display = markerActionsEnabled ? 'block' : 'none';
    } catch (e) {
      console.warn('setMarkerActionEnabled error:', e);
    }
  }

  /**************************************************************************
   * 초기화
   ***************************************************************************/
  function init() {
    initFireSensors();

    // QWebChannel 초기화 (Qt 환경에서 pyHandler가 필요한 경우)
    if (typeof QWebChannel !== 'undefined') {
      try {
        new QWebChannel(qt.webChannelTransport, (channel) => {
          window.pyHandler = channel.objects.pyHandler || window.pyHandler;
          console.log('QWebChannel connected', !!window.pyHandler);
        });
      } catch (err) {
        console.warn("QWebChannel init failed:", err);
      }
    }

    // 줌 이벤트시 필요시 다른 동작 추가 가능
  }

  init();
  </script>
</body>
</html>
